import zipfile
from io import BytesIO


def parse_kmz(kmz_bytes: bytes) -> dict:
    """Unpack a KMZ (zip) stream and return the first <coordinates> element as
    a GeoJSON LineString. For simplicity we only handle the very common case
    of a single <Placemark><LineString> path. A real implementation should be
    more robust.
    """
    with zipfile.ZipFile(BytesIO(kmz_bytes)) as z:
        # find the KML file
        kml_name = next((n for n in z.namelist() if n.lower().endswith(".kml")), None)
        if not kml_name:
            raise ValueError("no .kml found in kmz")
        kml_data = z.read(kml_name).decode("utf-8")

    # crude extraction of coordinates; use lxml or BeautifulSoup in prod
    import re
    blocks = re.findall(r"<coordinates>([^<]+)</coordinates>", kml_data)
    if not blocks:
        raise ValueError("no coordinates in kml")

    def parse_block(text):
        pts = []
        for pair in text.strip().split():
            parts = pair.split(",")
            lon = float(parts[0])
            lat = float(parts[1])
            if len(parts) > 2 and parts[2]:
                try:
                    alt = float(parts[2])
                except ValueError:
                    alt = None
            else:
                alt = None
            if alt is not None:
                pts.append([lon, lat, alt])
            else:
                pts.append([lon, lat])
        return pts

    all_coords = [parse_block(b) for b in blocks]
    # if there's only one coordinate block, keep legacy return shape
    if len(all_coords) == 1:
        return {"type": "LineString", "coordinates": all_coords[0]}

    # otherwise return a FeatureCollection of LineStrings
    features = [
        {"type": "Feature", "geometry": {"type": "LineString", "coordinates": coords}}
        for coords in all_coords
    ]
    return {"type": "FeatureCollection", "features": features}


def kmz_to_obj(kmz_bytes: bytes, default_alt: float = 0.0, thickness: float = 0.0) -> str:
    """Convert a flight path inside a KMZ into a simple OBJ model.

    By default this produces a polyline identical to the legacy behavior. If
    ``thickness`` is positive a thin ribbon mesh is generated instead: each
    waypoint is duplicated at ``z`` and ``z+thickness`` and quad faces connect
    successive segments. Most mesh viewers will display the ribbon, solving the
    "invisible line" problem.

    :param kmz_bytes: raw KMZ content
    :param default_alt: altitude to use when none is present in the KML
    :param thickness: vertical size of the ribbon; zero disables mesh creation
    """
    geojson = parse_kmz(kmz_bytes)

    lines = ["# generated by droneflight.kmz.kmz_to_obj"]

    def emit_for_coords(coords, obj_index):
        # returns list of lines for this coords block and number of vertices emitted
        block_lines = [f"o flight_path_{obj_index}"]
        if thickness <= 0 or len(coords) < 2:
            for pt in coords:
                if len(pt) == 3:
                    lon, lat, alt = pt
                else:
                    lon, lat = pt
                    alt = default_alt
                block_lines.append(f"v {lon} {lat} {alt}")
            if len(coords) > 1:
                idxs = " ".join(str(i + 1) for i in range(len(coords)))
                block_lines.append(f"l {idxs}")
            return block_lines, len(coords)
        else:
            # each waypoint becomes two vertices
            for pt in coords:
                if len(pt) == 3:
                    lon, lat, alt = pt
                else:
                    lon, lat = pt
                    alt = default_alt
                block_lines.append(f"v {lon} {lat} {alt}")
                block_lines.append(f"v {lon} {lat} {alt + thickness}")
            # faces (local indexing) will be emitted by caller adjusting indices
            return block_lines, len(coords) * 2

    # support both single LineString and FeatureCollection
    if isinstance(geojson, dict) and geojson.get("type") == "FeatureCollection":
        vertex_offset = 0
        obj_i = 1
        for feat in geojson.get("features", []):
            coords = feat.get("geometry", {}).get("coordinates", [])
            block_lines, emitted = emit_for_coords(coords, obj_i)
            # append block lines but need to fix face indices if thickness used
            if thickness > 0 and emitted >= 4:
                # block_lines include vertices only; append them first
                for l in block_lines:
                    lines.append(l)
                # now emit faces using global indices
                n_pts = emitted // 2
                for i in range(n_pts - 1):
                    v1 = vertex_offset + 2 * i + 1
                    v2 = vertex_offset + 2 * (i + 1) + 1
                    v3 = v2 + 1
                    v4 = v1 + 1
                    lines.append(f"f {v1} {v2} {v3} {v4}")
                vertex_offset += emitted
            else:
                # for line/polyline cases we must adjust any line indices
                if any(l.startswith("l ") for l in block_lines):
                    # remap indices by adding vertex_offset
                    verts = [l for l in block_lines if l.startswith("v ")]
                    for l in verts:
                        lines.append(l)
                    for l in block_lines:
                        if l.startswith("l "):
                            parts = l.split()[1:]
                            remapped = " ".join(str(int(p) + vertex_offset) for p in parts)
                            lines.append(f"l {remapped}")
                    vertex_offset += len(verts)
                else:
                    for l in block_lines:
                        lines.append(l)
        return "\n".join(lines)

    # single LineString
    coords = geojson.get("coordinates", [])
    if thickness <= 0 or len(coords) < 2:
        for pt in coords:
            if len(pt) == 3:
                lon, lat, alt = pt
            else:
                lon, lat = pt
                alt = default_alt
            lines.append(f"v {lon} {lat} {alt}")
        if len(coords) > 1:
            idxs = " ".join(str(i + 1) for i in range(len(coords)))
            lines.append(f"l {idxs}")
        return "\n".join(lines)

    # ribbon for single LineString
    for pt in coords:
        if len(pt) == 3:
            lon, lat, alt = pt
        else:
            lon, lat = pt
            alt = default_alt
        lines.append(f"v {lon} {lat} {alt}")
        lines.append(f"v {lon} {lat} {alt + thickness}")
    for i in range(len(coords) - 1):
        v1 = 2 * i + 1
        v2 = v1 + 2
        v3 = v2 + 1
        v4 = v1 + 1
        lines.append(f"f {v1} {v2} {v3} {v4}")
    return "\n".join(lines)
