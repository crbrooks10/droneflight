import zipfile
from io import BytesIO


def parse_kmz(kmz_bytes: bytes) -> dict:
    """Unpack a KMZ (zip) stream and return the first <coordinates> element as
    a GeoJSON LineString. For simplicity we only handle the very common case
    of a single <Placemark><LineString> path. A real implementation should be
    more robust.
    """
    with zipfile.ZipFile(BytesIO(kmz_bytes)) as z:
        # find the KML file
        kml_name = next((n for n in z.namelist() if n.lower().endswith(".kml")), None)
        if not kml_name:
            raise ValueError("no .kml found in kmz")
        kml_data = z.read(kml_name).decode("utf-8")

    # crude extraction of coordinates; use lxml or BeautifulSoup in prod
    import re
    m = re.search(r"<coordinates>([^<]+)</coordinates>", kml_data)
    if not m:
        raise ValueError("no coordinates in kml")
    coords_text = m.group(1).strip()
    coords = []
    for pair in coords_text.split():
        parts = pair.split(",")
        lon = float(parts[0])
        lat = float(parts[1])
        # if altitude is supplied in the KML we preserve it, otherwise ignore
        if len(parts) > 2 and parts[2]:
            try:
                alt = float(parts[2])
            except ValueError:
                alt = None
        else:
            alt = None
        if alt is not None:
            coords.append([lon, lat, alt])
        else:
            coords.append([lon, lat])
    return {"type": "LineString", "coordinates": coords}


def kmz_to_obj(kmz_bytes: bytes, default_alt: float = 0.0, thickness: float = 0.0) -> str:
    """Convert a flight path inside a KMZ into a simple OBJ model.

    By default this produces a polyline identical to the legacy behavior. If
    ``thickness`` is positive a thin ribbon mesh is generated instead: each
    waypoint is duplicated at ``z`` and ``z+thickness`` and quad faces connect
    successive segments. Most mesh viewers will display the ribbon, solving the
    "invisible line" problem.

    :param kmz_bytes: raw KMZ content
    :param default_alt: altitude to use when none is present in the KML
    :param thickness: vertical size of the ribbon; zero disables mesh creation
    """
    geojson = parse_kmz(kmz_bytes)
    coords = geojson.get("coordinates", [])

    lines = ["# generated by droneflight.kmz.kmz_to_obj", "o flight_path"]

    if thickness <= 0 or len(coords) < 2:
        # simple line fallback
        for pt in coords:
            if len(pt) == 3:
                lon, lat, alt = pt
            else:
                lon, lat = pt
                alt = default_alt
            lines.append(f"v {lon} {lat} {alt}")
        if len(coords) > 1:
            idxs = " ".join(str(i + 1) for i in range(len(coords)))
            lines.append(f"l {idxs}")
    else:
        # build ribbon: each waypoint gives two vertices (base and top)
        for pt in coords:
            if len(pt) == 3:
                lon, lat, alt = pt
            else:
                lon, lat = pt
                alt = default_alt
            lines.append(f"v {lon} {lat} {alt}")
            lines.append(f"v {lon} {lat} {alt + thickness}")
        # create quad faces: for i-th segment connect vertices 2*i+1..2*(i+1)+2
        # indices are 1-based
        for i in range(len(coords) - 1):
            v1 = 2 * i + 1
            v2 = v1 + 2
            v3 = v2 + 1
            v4 = v1 + 1
            lines.append(f"f {v1} {v2} {v3} {v4}")
    return "\n".join(lines)
