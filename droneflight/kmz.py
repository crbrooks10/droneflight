"""Utilities for working with KMZ (Google Earth) files.

This module provides helpers used throughout the project for parsing simple
KMZ flight plans into GeoJSON and exporting them as lightweight 3D OBJ
models.  The original repository included a largely untested JavaScript
snippet here by mistake; the Python equivalents are implemented below.
"""

import re
import zipfile
from io import BytesIO
from typing import List, Dict, Any, Optional


def parse_kmz(kmz_data: bytes) -> Dict[str, Any]:
    """Return a GeoJSON LineString extracted from the first KML in ``kmz_data``.

    The helper searches for any ``*.kml`` file inside the KMZ archive and
    looks for ``<coordinates>`` elements.  Only the first set of coordinates
    is returned; the routine is intentionally minimal for the purposes of
    the unit tests and the demo frontend.
    """
    buf = BytesIO(kmz_data)
    with zipfile.ZipFile(buf, "r") as z:
        # find first KML file
        kml_name: Optional[str] = None
        for name in z.namelist():
            if name.lower().endswith(".kml"):
                kml_name = name
                break
        if kml_name is None:
            raise ValueError("no KML file found in KMZ archive")
        kml_bytes = z.read(kml_name)
    kml_text = kml_bytes.decode("utf-8", errors="ignore")

    coords: List[List[float]] = []
    for match in re.finditer(r"<coordinates>([^<]+)</coordinates>", kml_text):
        raw = match.group(1).strip()
        for part in raw.split():
            comps = part.split(",")
            if len(comps) >= 2:
                lon = float(comps[0])
                lat = float(comps[1])
                alt = float(comps[2]) if len(comps) >= 3 and comps[2] != "" else 0.0
                coords.append([lon, lat, alt])
    if not coords:
        raise ValueError("no coordinates found in KML file")
    return {"type": "LineString", "coordinates": coords}


def kmz_to_obj(kmz_data: bytes, thickness: float = 0.0) -> str:
    """Convert a KMZ flight plan into a simple Wavefront OBJ string.

    The returned model is either a polyline (``thickness <= 0``) or a narrow
    ribbon mesh when a positive ``thickness`` is given.  The geometry mirrors
    what :class:`droneflight.path_editor.FlightPathEditor` generates so that
    both backends remain consistent.
    """
    geo = parse_kmz(kmz_data)
    coords: List[List[float]] = geo.get("coordinates", [])
    lines: List[str] = ["# generated by kmz.kmz_to_obj", "o flight_path"]

    if thickness <= 0 or len(coords) < 2:
        for wp in coords:
            if len(wp) == 3:
                lon, lat, alt = wp
            else:
                lon, lat = wp
                alt = 0.0
            lines.append(f"v {lon} {lat} {alt}")
        if len(coords) > 1:
            idxs = " ".join(str(i + 1) for i in range(len(coords)))
            lines.append(f"l {idxs}")
    else:
        # create ribbon mesh
        for wp in coords:
            if len(wp) == 3:
                lon, lat, alt = wp
            else:
                lon, lat = wp
                alt = 0.0
            lines.append(f"v {lon} {lat} {alt}")
            lines.append(f"v {lon} {lat} {alt + thickness}")
        for i in range(len(coords) - 1):
            v1 = 2 * i + 1
            v2 = v1 + 2
            v3 = v2 + 1
            v4 = v1 + 1
            lines.append(f"f {v1} {v2} {v3} {v4}")
    return "\n".join(lines)
