<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DroneFlight Planner</title>
    <script src="/static/cesium.js"></script>
    <link href="/static/widgets.css" rel="stylesheet">
    <script src="/static/jszip.min.js"></script>
    <style>
        body, html { height: 100%; margin: 0; padding: 0; }
        #mainContainer { display: flex; height: 100%; }
        #weatherPanel { flex: 1; order: 0; border-right: 1px solid #ccc; }
        #leftPanel { flex: 4; order: 1; display: flex; flex-direction: column; }
        #cesiumContainer { flex: 1; }
        #controls { padding: 8px; }
        #weatherPanel iframe { width: 100%; height: 100%; }
    </style>
</head>
<body>
<div id="mainContainer">
    <div id="weatherPanel">
        <iframe id="weatherFrame" src="/weather" sandbox="allow-scripts allow-same-origin" frameborder="0" onerror="this.parentElement.innerText='Weather unavailable';"></iframe>
    </div>
    <div id="leftPanel">
        <div id="controls">
            <input type="file" id="kmzInput">
            <button id="uploadBtn">Upload KMZ</button>
            <label for="widthInput">Corridor width (m):</label>
            <input type="number" id="widthInput" value="10" min="0" step="1" style="width:60px;" />
            <button id="startDraw">Start new line</button>
            <button id="finishDraw">Finish line</button>
            <button id="clearDrawings">Clear drawings</button>
            <button id="droneBtn">Trace Drone</button>    <br />
            <label for="coordsText">Or paste lon,lat pairs:</label><br/>
            <textarea id="coordsText" rows="3" cols="60" placeholder="-122.42,37.77 -122.41,37.78"></textarea><br/>
            <button id="loadCoordsBtn">Load coordinates</button>
            <br/>
            <label for="objOutput">Generated OBJ:</label><br/>
            <pre id="objOutput" style="height:150px; overflow:auto; background:#f0f0f0;
                padding:8px; border:1px solid #ccc;"></pre>
        </div>
        <div id="cesiumContainer"></div>
    </div>
</div>
<script>
    let viewer;
    try {
        viewer = new Cesium.Viewer('cesiumContainer', {
            terrainProvider: Cesium.createWorldTerrain()
        });
    } catch (e) {
        console.error('Cesium initialization failed', e);
        document.getElementById('cesiumContainer').innerText = '3D view failed to load; see console for details.';
        viewer = null;
    }

    // drawing/editing state
    let drawing = false;
    let currentPositions = [];
    let currentEntity = null;
    let pointEntities = [];
    let dragIndex = null;

    const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
    handler.setInputAction(function(click) {
        if (drawing) {
            const cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
            if (cartesian) {
                currentPositions.push(cartesian);
                if (!currentEntity) {
                    currentEntity = viewer.entities.add({
                        polyline: {
                            positions: new Cesium.CallbackProperty(function() { return currentPositions; }, false),
                            width: 4,
                            material: Cesium.Color.BLUE
                        }
                    });
                }
            }
        } else {
            // attempt to start dragging an existing point
            const picked = viewer.scene.pick(click.position);
            if (Cesium.defined(picked) && pointEntities.includes(picked.id)) {
                dragIndex = pointEntities.indexOf(picked.id);
            }
        }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    handler.setInputAction(function(movement) {
        if (dragIndex !== null) {
            const cart = viewer.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid);
            if (cart) {
                currentPositions[dragIndex] = cart;
                // update associated point entity
                pointEntities[dragIndex].position = cart;
            }
        }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    handler.setInputAction(function() {
        dragIndex = null;
    }, Cesium.ScreenSpaceEventType.LEFT_UP);

    document.getElementById('startDraw').addEventListener('click', () => {
        drawing = true;
        currentPositions = [];
        if (currentEntity) {
            viewer.entities.remove(currentEntity);
            currentEntity = null;
        }
    });
    document.getElementById('finishDraw').addEventListener('click', () => {
        drawing = false;
    });
    document.getElementById('clearDrawings').addEventListener('click', () => {
        drawing = false;
        currentPositions = [];
        if (currentEntity) {
            viewer.entities.remove(currentEntity);
            currentEntity = null;
        }
    });

    // handling for KMZ or manual coordinates
    let currentGroups = [];

    function renderGroups() {
        viewer.entities.removeAll();
        currentEntity = null;
        currentPositions = [];
        pointEntities = [];
        let firstEnt = null;
        currentGroups.forEach((coordsArr) => {
            const e = viewer.entities.add({
                corridor: {
                    positions: Cesium.Cartesian3.fromDegreesArray(coordsArr),
                    width: parseFloat(document.getElementById('widthInput').value) || 0,
                    material: Cesium.Color.RED.withAlpha(0.8),
                    height: 0,
                    extrudedHeight: 5.0
                }
            });
            if (!firstEnt) firstEnt = e;
        });
        if (firstEnt) viewer.zoomTo(firstEnt);
        if (currentGroups.length) {
            currentPositions = Cesium.Cartesian3.fromDegreesArray(currentGroups[0]);
            // create editable polyline
            currentEntity = viewer.entities.add({
                polyline: {
                    positions: new Cesium.CallbackProperty(function() { return currentPositions; }, false),
                    width: 4,
                    material: Cesium.Color.BLUE
                }
            });
            // add draggable points
            currentPositions.forEach((pos) => {
                const pt = viewer.entities.add({
                    position: pos,
                    point: { pixelSize: 8, color: Cesium.Color.YELLOW }
                });
                pointEntities.push(pt);
            });
        }
    }

    document.getElementById('uploadBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('kmzInput');
        if (!fileInput.files.length) return;
        const file = fileInput.files[0];

        const form = new FormData();
        form.append('file', file);

        try {
            const resp = await fetch('/upload-kmz', { method: 'POST', body: form });
            if (!resp.ok) {
                const text = await resp.text();
                alert('Server error: ' + text);
                return;
            }
            const data = await resp.json();
            if (data.error) {
                alert('Error: ' + data.error);
                return;
            }
            // display geojson if needed
            if (data.geojson) {
                // convert geojson coords to lon/lat pairs only (drop altitude)
                const coords = (data.geojson.coordinates || []).map(c => [c[0], c[1]]);
                // flatten into single array
                const flat = [];
                coords.forEach(c => { flat.push(c[0]); flat.push(c[1]); });
                currentGroups = [flat];
                renderGroups();
            }
            if (data.obj) {
                document.getElementById('objOutput').textContent = data.obj;
                // render the OBJ as a 3D polyline using vertex heights
                try {
                    const verts = [];
                    data.obj.split('\n').forEach(line => {
                        if (line.startsWith('v ')) {
                            const parts = line.split(/\s+/);
                            if (parts.length >= 4) {
                                verts.push({
                                    lon: parseFloat(parts[1]),
                                    lat: parseFloat(parts[2]),
                                    alt: parseFloat(parts[3])
                                });
                            }
                        }
                    });
                    if (verts.length > 1) {
                        const positions = verts.map(v => Cesium.Cartesian3.fromDegrees(v.lon, v.lat, v.alt));
                        viewer.entities.add({
                            polyline: {
                                positions: positions,
                                width: 4,
                                material: Cesium.Color.GREEN
                            }
                        });
                    }
                } catch (ex) {
                    console.error('failed to render OBJ', ex);
                }
            }
        } catch (err) {
            alert('Upload failed: ' + err);
        }
    });

    document.getElementById('loadCoordsBtn').addEventListener('click', () => {
        const text = document.getElementById('coordsText').value.trim();
        if (!text) return;
        const parts = text.split(/\s+/);
        const flat = [];
        for (const p of parts) {
            const comps = p.split(',');
            if (comps.length >= 2) {
                flat.push(parseFloat(comps[0]));
                flat.push(parseFloat(comps[1]));
            }
        }
        if (flat.length < 4) {
            alert('need at least two coordinate pairs');
            return;
        }
        currentGroups = [flat];
        renderGroups();
    });

</script>
</body>
</html>

US Aviation Sectional Chart - Full United States Downloader
=============================================================
Downloads the FAA VFR Sectional Chart imagery covering the entire
United States (Contiguous US, Alaska, and/or Hawaii) from a public
ArcGIS MapServer, producing georeferenced output files.
Outputs:
  - A high-resolution PNG/JPG of the sectional chart
  - A world file (.pgw/.jgw) for georeferencing in GIS software
  - A KMZ file with the chart as a ground overlay for Google Earth
Data source: Texas A&M University GIS Lab - FAA Sectional Charts MapServer
  https://twcgis.tamu.edu/arcgis/rest/services/Aviation/FAA_Sectional_Charts/MapServer
Usage:
    python us_sectional_chart_downloader.py
    python us_sectional_chart_downloader.py --region conus --dpi 200
    python us_sectional_chart_downloader.py --region all --output-dir ./charts
    python us_sectional_chart_downloader.py --region hawaii --format jpg
"""
import argparse
import io
import math
import os
import sys
import time
import zipfile
from pathlib import Path
import requests
from PIL import Image
# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------
# TAMU ArcGIS REST endpoint for FAA Sectional Charts
ARCGIS_EXPORT_URL = (
    "https://twcgis.tamu.edu/arcgis/rest/services/"
    "Aviation/FAA_Sectional_Charts/MapServer/export"
)
# Maximum image dimension the ArcGIS server will return per request
MAX_TILE_DIM = 4096
# Predefined regions (WGS84 / EPSG:4326 bounds)
REGIONS = {
    "conus": {
        "name": "Contiguous United States (Lower 48)",
        "min_lon": -125.5,
        "max_lon": -66.0,
        "min_lat": 24.0,
        "max_lat": 50.0,
    },
    "alaska": {
        "name": "Alaska",
        "min_lon": -180.0,
        "max_lon": -129.0,
        "min_lat": 51.0,
        "max_lat": 72.0,
    },
    "hawaii": {
        "name": "Hawaii",
        "min_lon": -161.0,
        "max_lon": -154.5,
        "min_lat": 18.5,
        "max_lat": 22.5,
    },
}
# Resolution presets: name -> (approximate pixels per degree longitude)
RESOLUTION_PRESETS = {
    "low": 200,       # ~60 MB final image, fast download
    "medium": 500,    # ~200 MB final image
    "high": 1000,     # ~600 MB final image
    "ultra": 1500,    # ~1+ GB final image, slow download
}
# ---------------------------------------------------------------------------
# Tile Download Engine
# ---------------------------------------------------------------------------
def fetch_tile(
    bounds: dict,
    width: int,
    height: int,
    img_format: str = "png",
    dpi: int = 150,
    retries: int = 3,
) -> bytes:
    """
    Fetch a single tile of FAA Sectional Chart imagery from the ArcGIS
    MapServer export endpoint.
    """
    bbox_str = (
        f"{bounds['min_lon']},{bounds['min_lat']},"
        f"{bounds['max_lon']},{bounds['max_lat']}"
    )
    params = {
        "bbox": bbox_str,
        "bboxSR": "4326",
        "imageSR": "4326",
        "size": f"{width},{height}",
        "format": img_format,
        "dpi": dpi,
        "transparent": "true",
        "layers": "show:0",  # FAA_Sectional_Chart_Mosaic layer
        "f": "image",
    }
    for attempt in range(1, retries + 1):
        try:
            resp = requests.get(ARCGIS_EXPORT_URL, params=params, timeout=180)
            resp.raise_for_status()
            content_type = resp.headers.get("Content-Type", "")
            if "image" not in content_type and "octet" not in content_type:
                raise RuntimeError(
                    f"Server returned non-image response: {content_type}\n"
                    f"{resp.text[:300]}"
                )
            return resp.content
        except (requests.RequestException, RuntimeError) as e:
            if attempt < retries:
                wait_time = 2 ** attempt
                print(f"    Retry {attempt}/{retries} after error: {e}")
                print(f"    Waiting {wait_time}s...")
                time.sleep(wait_time)
            else:
                raise RuntimeError(
                    f"Failed to fetch tile after {retries} attempts: {e}"
                ) from e
    # Should not reach here
    raise RuntimeError("Unexpected state in fetch_tile")
def compute_tile_grid(
    bounds: dict,
    pixels_per_deg: int,
    max_tile_dim: int = MAX_TILE_DIM,
) -> dict:
    """
    Compute the tiling grid for a given bounding box and resolution.
    Returns a dict with:
      - total_width, total_height: final image dimensions in pixels
      - n_cols, n_rows: number of tiles in each direction
      - tile_width, tile_height: pixel dimensions of each tile
      - lon_step, lat_step: geographic extent of each tile
    """
    lon_range = bounds["max_lon"] - bounds["min_lon"]
    lat_range = bounds["max_lat"] - bounds["min_lat"]
    # Account for latitude distortion in width
    mid_lat = (bounds["min_lat"] + bounds["max_lat"]) / 2.0
    cos_lat = math.cos(math.radians(mid_lat))
    total_width = int(lon_range * pixels_per_deg * cos_lat)
    total_height = int(lat_range * pixels_per_deg)
    # Ensure minimum size
    total_width = max(total_width, 256)
    total_height = max(total_height, 256)
    # Compute number of tiles needed
    n_cols = math.ceil(total_width / max_tile_dim)
    n_rows = math.ceil(total_height / max_tile_dim)
    # Tile dimensions (may be smaller than max_tile_dim)
    tile_width = math.ceil(total_width / n_cols)
    tile_height = math.ceil(total_height / n_rows)
    # Clamp tile dimensions to max
    tile_width = min(tile_width, max_tile_dim)
    tile_height = min(tile_height, max_tile_dim)
    lon_step = lon_range / n_cols
    lat_step = lat_range / n_rows
    return {
        "total_width": tile_width * n_cols,
        "total_height": tile_height * n_rows,
        "n_cols": n_cols,
        "n_rows": n_rows,
        "tile_width": tile_width,
        "tile_height": tile_height,
        "lon_step": lon_step,
        "lat_step": lat_step,
    }
def download_region(
    bounds: dict,
    pixels_per_deg: int,
    img_format: str = "png",
    dpi: int = 150,
) -> tuple[Image.Image, dict]:
    """
    Download sectional chart imagery for a region by tiling.
    Returns the stitched PIL Image and the tile grid info dict.
    """
    grid = compute_tile_grid(bounds, pixels_per_deg)
    n_cols = grid["n_cols"]
    n_rows = grid["n_rows"]
    tile_w = grid["tile_width"]
    tile_h = grid["tile_height"]
    total_tiles = n_cols * n_rows
    print(f"  Image size:  {grid['total_width']} x {grid['total_height']} pixels")
    print(f"  Tile grid:   {n_cols} cols x {n_rows} rows = {total_tiles} tiles")
    print(f"  Tile size:   {tile_w} x {tile_h} pixels")
    print()
    # Create the full canvas
    canvas = Image.new("RGBA", (grid["total_width"], grid["total_height"]))
    completed = 0
    start_time = time.time()
    for row in range(n_rows):
        for col in range(n_cols):
            completed += 1
            elapsed = time.time() - start_time
            rate = completed / elapsed if elapsed > 0 else 0
            remaining = (total_tiles - completed) / rate if rate > 0 else 0
            tile_bounds = {
                "min_lon": bounds["min_lon"] + col * grid["lon_step"],
                "max_lon": bounds["min_lon"] + (col + 1) * grid["lon_step"],
                # Rows go top (max_lat) to bottom (min_lat)
                "min_lat": bounds["max_lat"] - (row + 1) * grid["lat_step"],
                "max_lat": bounds["max_lat"] - row * grid["lat_step"],
            }
            print(
                f"  [{completed:3d}/{total_tiles}] "
                f"Row {row+1}/{n_rows}, Col {col+1}/{n_cols}  "
                f"({elapsed:.0f}s elapsed, ~{remaining:.0f}s remaining)",
                end="",
                flush=True,
            )
            data = fetch_tile(tile_bounds, tile_w, tile_h, img_format, dpi)
            tile_img = Image.open(io.BytesIO(data)).convert("RGBA")
            canvas.paste(tile_img, (col * tile_w, row * tile_h))
            print(f"  OK ({len(data):,} bytes)")
            # Brief pause to be polite to the server
            if total_tiles > 1:
                time.sleep(0.3)
    elapsed = time.time() - start_time
    print(f"\n  Download complete in {elapsed:.1f}s")
    return canvas, grid
# ---------------------------------------------------------------------------
# Output Generation
# ---------------------------------------------------------------------------
def write_world_file(path: str, bounds: dict, width: int, height: int) -> None:
    """Write a world file for georeferencing (EPSG:4326)."""
    pixel_x = (bounds["max_lon"] - bounds["min_lon"]) / width
    pixel_y = -(bounds["max_lat"] - bounds["min_lat"]) / height
    x_origin = bounds["min_lon"] + pixel_x / 2
    y_origin = bounds["max_lat"] + pixel_y / 2
    with open(path, "w") as f:
        f.write(f"{pixel_x:.12f}\n")
        f.write("0.0\n")
        f.write("0.0\n")
        f.write(f"{pixel_y:.12f}\n")
        f.write(f"{x_origin:.12f}\n")
        f.write(f"{y_origin:.12f}\n")
    print(f"  World file: {path}")
def create_output_kmz(
    image_path: str,
    bounds: dict,
    output_path: str,
    img_format: str = "png",
) -> None:
    """
    Create a KMZ file with the chart as a GroundOverlay.
    Reads the image from disk to avoid holding it all in memory twice.
    """
    img_filename = f"sectional_chart.{img_format}"
    kml_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>FAA VFR Sectional Charts - United States</name>
    <description>
      US Aviation Sectional Chart coverage.
      Source: FAA via TAMU ArcGIS MapServer.
    </description>
    <GroundOverlay>
      <name>Sectional Charts</name>
      <Icon>
        <href>{img_filename}</href>
      </Icon>
      <LatLonBox>
        <north>{bounds['max_lat']:.8f}</north>
        <south>{bounds['min_lat']:.8f}</south>
        <east>{bounds['max_lon']:.8f}</east>
        <west>{bounds['min_lon']:.8f}</west>
        <rotation>0</rotation>
      </LatLonBox>
    </GroundOverlay>
  </Document>
</kml>"""
    with zipfile.ZipFile(output_path, "w", zipfile.ZIP_DEFLATED) as zf:
        zf.writestr("doc.kml", kml_content)
        # Write image from file (avoids double memory usage)
        zf.write(image_path, img_filename)
    print(f"  KMZ overlay: {output_path}")
# ---------------------------------------------------------------------------
# Main Pipeline
# ---------------------------------------------------------------------------
def process_region(
    region_key: str,
    bounds: dict,
    region_name: str,
    output_dir: str,
    resolution: str,
    dpi: int,
    img_format: str,
) -> dict:
    """Download and save sectional chart for one region."""
    pixels_per_deg = RESOLUTION_PRESETS.get(resolution, 500)
    print(f"\n{'='*60}")
    print(f"  Downloading: {region_name}")
    print(f"  Resolution:  {resolution} ({pixels_per_deg} px/deg)")
    print(f"  Bounds:      {bounds['min_lat']:.1f}N to {bounds['max_lat']:.1f}N, "
          f"{bounds['min_lon']:.1f}W to {bounds['max_lon']:.1f}W")
    print(f"{'='*60}\n")
    # Download
    chart_img, grid = download_region(bounds, pixels_per_deg, img_format, dpi)
    # Save image
    ext = img_format.lower()
    img_path = os.path.join(output_dir, f"us_sectional_{region_key}.{ext}")
    print(f"\n  Saving output files...")
    if ext == "jpg":
        chart_img.convert("RGB").save(img_path, "JPEG", quality=95)
    else:
        chart_img.save(img_path, "PNG", optimize=True)
    file_size = os.path.getsize(img_path)
    print(f"  Chart image: {img_path} ({file_size / 1024 / 1024:.1f} MB)")
    # World file
    wf_ext = "pgw" if ext == "png" else "jgw"
    wf_path = os.path.join(output_dir, f"us_sectional_{region_key}.{wf_ext}")
    write_world_file(wf_path, bounds, grid["total_width"], grid["total_height"])
    # KMZ overlay
    kmz_path = os.path.join(output_dir, f"us_sectional_{region_key}.kmz")
    create_output_kmz(img_path, bounds, kmz_path, ext)
    kmz_size = os.path.getsize(kmz_path)
    print(f"  KMZ size: {kmz_size / 1024 / 1024:.1f} MB")
    return {
        "region": region_key,
        "image": img_path,
        "world_file": wf_path,
        "kmz": kmz_path,
        "image_size": (grid["total_width"], grid["total_height"]),
        "bounds": bounds,
    }
def main():
    parser = argparse.ArgumentParser(
        description="Download FAA Sectional Charts for the entire United States.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Regions:
  conus    Contiguous US / Lower 48 states (default)
  alaska   Alaska
  hawaii   Hawaii
  all      All three regions
Resolution presets:
  low      ~200 px/deg  - Fast, smaller files
  medium   ~500 px/deg  - Good balance (default)
  high     ~1000 px/deg - High detail, large files
  ultra    ~1500 px/deg - Maximum detail, very large files
Examples:
  python us_sectional_chart_downloader.py
  python us_sectional_chart_downloader.py --region conus --resolution medium
  python us_sectional_chart_downloader.py --region all --output-dir ./charts
  python us_sectional_chart_downloader.py --region hawaii --format jpg
        """,
    )
    parser.add_argument(
        "--region",
        choices=["conus", "alaska", "hawaii", "all"],
        default="all",
        help="Region to download (default: all)",
    )
    parser.add_argument(
        "--resolution",
        choices=["low", "medium", "high", "ultra"],
        default="medium",
        help="Resolution preset (default: medium)",
    )
    parser.add_argument(
        "--output-dir",
        default="./us_sectional_charts",
        help="Output directory (default: ./us_sectional_charts)",
    )
    parser.add_argument(
        "--dpi",
        type=int,
        default=150,
        help="Server DPI hint (default: 150)",
    )
    parser.add_argument(
        "--format",
        choices=["png", "jpg"],
        default="png",
        help="Output image format (default: png)",
    )
    args = parser.parse_args()
    output_dir = args.output_dir
    os.makedirs(output_dir, exist_ok=True)
    # Determine which regions to download
    if args.region == "all":
        region_keys = ["conus", "alaska", "hawaii"]
    else:
        region_keys = [args.region]
    print(f"\n{'#'*60}")
    print(f"  US Aviation Sectional Chart Downloader")
    print(f"{'#'*60}")
    print(f"  Regions:    {', '.join(region_keys)}")
    print(f"  Resolution: {args.resolution}")
    print(f"  Format:     {args.format}")
    print(f"  Output:     {output_dir}")
    all_results = []
    for key in region_keys:
        region = REGIONS[key]
        bounds = {k: v for k, v in region.items() if k != "name"}
        result = process_region(
            region_key=key,
            bounds=bounds,
            region_name=region["name"],
            output_dir=output_dir,
            resolution=args.resolution,
            dpi=args.dpi,
            img_format=args.format,
        )
        all_results.append(result)
    # Final summary
    print(f"\n{'#'*60}")
    print(f"  Download Complete!")
    print(f"{'#'*60}")
    print(f"\n  Output directory: {output_dir}\n")
    for r in all_results:
        print(f"  {r['region'].upper()}:")
        print(f"    Image:      {r['image']} ({r['image_size'][0]}x{r['image_size'][1]} px)")
        print(f"    World file:  {r['world_file']}")
        print(f"    KMZ overlay: {r['kmz']}")
        print()
    print(f"  How to use:")
    print(f"    - Load the .kmz files in Google Earth to view sectional charts.")
    print(f"    - Use the image + world file in QGIS/ArcGIS (CRS: EPSG:4326 / WGS84).")
    print()
if __name__ == "__main__":
    main()