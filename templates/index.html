<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DroneFlight Planner</title>
    <script src="/static/cesium.js"></script>
    <link href="/static/widgets.css" rel="stylesheet">
    <script src="/static/jszip.min.js"></script>
    <style>
        body, html { height: 100%; margin: 0; padding: 0; }
        #mainContainer { display: flex; height: 100%; }
        #weatherPanel { flex: 1; order: 0; border-right: 1px solid #ccc; }
        #leftPanel { flex: 4; order: 1; display: flex; flex-direction: column; }
        #cesiumContainer { flex: 1; }
        #controls { padding: 8px; }
        #weatherPanel iframe { width: 100%; height: 100%; }
    </style>
</head>
<body>
<div id="mainContainer">
    <div id="weatherPanel">
        <iframe id="weatherFrame" src="/weather" sandbox="allow-scripts allow-same-origin" frameborder="0" onerror="this.parentElement.innerText='Weather unavailable';"></iframe>
    </div>
    <div id="leftPanel">
        <div id="controls">
            <input type="file" id="kmzInput">
            <button id="uploadBtn">Upload KMZ</button>
            <label for="widthInput">Corridor width (m):</label>
            <input type="number" id="widthInput" value="10" min="0" step="1" style="width:60px;" />
            <button id="startDraw">Start new line</button>
            <button id="finishDraw">Finish line</button>
            <button id="clearDrawings">Clear drawings</button>    <br />
            <label for="coordsText">Or paste lon,lat pairs:</label><br/>
            <textarea id="coordsText" rows="3" cols="60" placeholder="-122.42,37.77 -122.41,37.78"></textarea><br/>
            <button id="loadCoordsBtn">Load coordinates</button>
            <br/>
            <label for="objOutput">Generated OBJ:</label><br/>
            <pre id="objOutput" style="height:150px; overflow:auto; background:#f0f0f0;
                padding:8px; border:1px solid #ccc;"></pre>
        </div>
        <div id="cesiumContainer"></div>
    </div>
</div>
<script>
    let viewer;
    try {
        viewer = new Cesium.Viewer('cesiumContainer', {
            terrainProvider: Cesium.createWorldTerrain()
        });
    } catch (e) {
        console.error('Cesium initialization failed', e);
        document.getElementById('cesiumContainer').innerText = '3D view failed to load; see console for details.';
        viewer = null;
    }

    // drawing/editing state
    let drawing = false;
    let currentPositions = [];
    let currentEntity = null;
    let pointEntities = [];
    let dragIndex = null;

    const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
    handler.setInputAction(function(click) {
        if (drawing) {
            const cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
            if (cartesian) {
                currentPositions.push(cartesian);
                if (!currentEntity) {
                    currentEntity = viewer.entities.add({
                        polyline: {
                            positions: new Cesium.CallbackProperty(function() { return currentPositions; }, false),
                            width: 4,
                            material: Cesium.Color.BLUE
                        }
                    });
                }
            }
        } else {
            // attempt to start dragging an existing point
            const picked = viewer.scene.pick(click.position);
            if (Cesium.defined(picked) && pointEntities.includes(picked.id)) {
                dragIndex = pointEntities.indexOf(picked.id);
            }
        }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    handler.setInputAction(function(movement) {
        if (dragIndex !== null) {
            const cart = viewer.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid);
            if (cart) {
                currentPositions[dragIndex] = cart;
                // update associated point entity
                pointEntities[dragIndex].position = cart;
            }
        }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    handler.setInputAction(function() {
        dragIndex = null;
    }, Cesium.ScreenSpaceEventType.LEFT_UP);

    document.getElementById('startDraw').addEventListener('click', () => {
        drawing = true;
        currentPositions = [];
        if (currentEntity) {
            viewer.entities.remove(currentEntity);
            currentEntity = null;
        }
    });
    document.getElementById('finishDraw').addEventListener('click', () => {
        drawing = false;
    });
    document.getElementById('clearDrawings').addEventListener('click', () => {
        drawing = false;
        currentPositions = [];
        if (currentEntity) {
            viewer.entities.remove(currentEntity);
            currentEntity = null;
        }
    });

    // handling for KMZ or manual coordinates
    let currentGroups = [];

    function renderGroups() {
        viewer.entities.removeAll();
        currentEntity = null;
        currentPositions = [];
        pointEntities = [];
        let firstEnt = null;
        currentGroups.forEach((coordsArr) => {
            const e = viewer.entities.add({
                corridor: {
                    positions: Cesium.Cartesian3.fromDegreesArray(coordsArr),
                    width: parseFloat(document.getElementById('widthInput').value) || 0,
                    material: Cesium.Color.RED.withAlpha(0.8),
                    height: 0,
                    extrudedHeight: 5.0
                }
            });
            if (!firstEnt) firstEnt = e;
        });
        if (firstEnt) viewer.zoomTo(firstEnt);
        if (currentGroups.length) {
            currentPositions = Cesium.Cartesian3.fromDegreesArray(currentGroups[0]);
            // create editable polyline
            currentEntity = viewer.entities.add({
                polyline: {
                    positions: new Cesium.CallbackProperty(function() { return currentPositions; }, false),
                    width: 4,
                    material: Cesium.Color.BLUE
                }
            });
            // add draggable points
            currentPositions.forEach((pos) => {
                const pt = viewer.entities.add({
                    position: pos,
                    point: { pixelSize: 8, color: Cesium.Color.YELLOW }
                });
                pointEntities.push(pt);
            });
        }
    }

    document.getElementById('uploadBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('kmzInput');
        if (!fileInput.files.length) return;
        const file = fileInput.files[0];

        const form = new FormData();
        form.append('file', file);

        try {
            const resp = await fetch('/upload-kmz', { method: 'POST', body: form });
            if (!resp.ok) {
                const text = await resp.text();
                alert('Server error: ' + text);
                return;
            }
            const data = await resp.json();
            if (data.error) {
                alert('Error: ' + data.error);
                return;
            }
            // display geojson if needed
            if (data.geojson) {
                // convert geojson coords to lon/lat pairs only (drop altitude)
                const coords = (data.geojson.coordinates || []).map(c => [c[0], c[1]]);
                // flatten into single array
                const flat = [];
                coords.forEach(c => { flat.push(c[0]); flat.push(c[1]); });
                currentGroups = [flat];
                renderGroups();
            }
            if (data.obj) {
                document.getElementById('objOutput').textContent = data.obj;
                // render the OBJ as a 3D polyline using vertex heights
                try {
                    const verts = [];
                    data.obj.split('\n').forEach(line => {
                        if (line.startsWith('v ')) {
                            const parts = line.split(/\s+/);
                            if (parts.length >= 4) {
                                verts.push({
                                    lon: parseFloat(parts[1]),
                                    lat: parseFloat(parts[2]),
                                    alt: parseFloat(parts[3])
                                });
                            }
                        }
                    });
                    if (verts.length > 1) {
                        const positions = verts.map(v => Cesium.Cartesian3.fromDegrees(v.lon, v.lat, v.alt));
                        viewer.entities.add({
                            polyline: {
                                positions: positions,
                                width: 4,
                                material: Cesium.Color.GREEN
                            }
                        });
                    }
                } catch (ex) {
                    console.error('failed to render OBJ', ex);
                }
            }
        } catch (err) {
            alert('Upload failed: ' + err);
        }
    });

    document.getElementById('loadCoordsBtn').addEventListener('click', () => {
        const text = document.getElementById('coordsText').value.trim();
        if (!text) return;
        const parts = text.split(/\s+/);
        const flat = [];
        for (const p of parts) {
            const comps = p.split(',');
            if (comps.length >= 2) {
                flat.push(parseFloat(comps[0]));
                flat.push(parseFloat(comps[1]));
            }
        }
        if (flat.length < 4) {
            alert('need at least two coordinate pairs');
            return;
        }
        currentGroups = [flat];
        renderGroups();
    });

</script>
</body>
</html>

